# Seedling HQ Infrastructure Makefile
# Convenient commands for managing AWS Lambda deployment

.PHONY: help init plan apply destroy clean validate fmt dev prod logs test

# Default environment
ENV ?= dev

# Default help command
help: ## Show this help message
	@echo "Seedling HQ Infrastructure Commands"
	@echo "==================================="
	@echo ""
	@echo "Available commands:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}'
	@echo ""
	@echo "Environment options:"
	@echo "  ENV=dev     Deploy to development (default)"
	@echo "  ENV=prod    Deploy to production"
	@echo ""
	@echo "Examples:"
	@echo "  make init               # Initialize Terraform"
	@echo "  make plan ENV=dev       # Plan development deployment"
	@echo "  make apply ENV=prod     # Deploy to production"
	@echo "  make destroy ENV=dev    # Destroy development infrastructure"

init: ## Initialize Terraform
	@echo "ğŸš€ Initializing Terraform..."
	terraform init

validate: ## Validate Terraform configuration
	@echo "âœ… Validating Terraform configuration..."
	terraform validate

fmt: ## Format Terraform files
	@echo "ğŸ“ Formatting Terraform files..."
	terraform fmt -recursive

plan: validate ## Plan infrastructure changes
	@echo "ğŸ“‹ Planning infrastructure changes for $(ENV)..."
	terraform plan -var-file="environments/$(ENV).tfvars"

apply: validate ## Apply infrastructure changes
	@echo "ğŸš¢ Applying infrastructure changes for $(ENV)..."
	terraform apply -var-file="environments/$(ENV).tfvars"

destroy: ## Destroy infrastructure
	@echo "ğŸ’¥ Destroying infrastructure for $(ENV)..."
	@echo "âš ï¸  This will delete all resources. Are you sure? [y/N]"
	@read confirm && [ "$$confirm" = "y" ] || [ "$$confirm" = "Y" ]
	terraform destroy -var-file="environments/$(ENV).tfvars"

clean: ## Clean build artifacts and Terraform files
	@echo "ğŸ§¹ Cleaning build artifacts..."
	rm -rf builds/
	rm -rf .terraform/
	rm -f .terraform.lock.hcl
	rm -f terraform.tfstate*
	rm -f *.tfplan

# Development environment shortcuts
dev: ## Deploy to development environment
	@echo "ğŸ”§ Deploying to development environment..."
	$(MAKE) apply ENV=dev

dev-plan: ## Plan development deployment
	@echo "ğŸ“‹ Planning development deployment..."
	$(MAKE) plan ENV=dev

dev-destroy: ## Destroy development environment
	@echo "ğŸ’¥ Destroying development environment..."
	$(MAKE) destroy ENV=dev

# Production environment shortcuts
prod: ## Deploy to production environment
	@echo "ğŸ­ Deploying to production environment..."
	$(MAKE) apply ENV=prod

prod-plan: ## Plan production deployment
	@echo "ğŸ“‹ Planning production deployment..."
	$(MAKE) plan ENV=prod

prod-destroy: ## Destroy production environment
	@echo "ğŸ’¥ Destroying production environment..."
	$(MAKE) destroy ENV=prod

# Utility commands
outputs: ## Show Terraform outputs
	@echo "ğŸ“Š Terraform outputs for $(ENV):"
	terraform output

logs: ## View Lambda function logs (requires AWS CLI)
	@echo "ğŸ“ Viewing Lambda function logs..."
	@FUNCTION_NAME=$$(terraform output -raw lambda_function_name 2>/dev/null || echo "seedling-hq-api-$(ENV)"); \
	aws logs tail "/aws/lambda/$$FUNCTION_NAME" --follow

test: ## Test deployed API endpoints
	@echo "ğŸ§ª Testing API endpoints for $(ENV)..."
	@echo ""
	@echo "Testing health endpoint via API Gateway:"
	@API_URL=$$(terraform output -raw api_gateway_url 2>/dev/null); \
	if [ -n "$$API_URL" ]; then \
		curl -s "$$API_URL/health" | jq . || curl -s "$$API_URL/health"; \
	else \
		echo "âŒ API Gateway URL not found. Run 'make apply ENV=$(ENV)' first."; \
	fi
	@echo ""
	@echo "Testing health endpoint via Lambda URL:"
	@LAMBDA_URL=$$(terraform output -raw lambda_function_url 2>/dev/null); \
	if [ -n "$$LAMBDA_URL" ]; then \
		curl -s "$$LAMBDA_URL/health" | jq . || curl -s "$$LAMBDA_URL/health"; \
	else \
		echo "âŒ Lambda URL not found. Run 'make apply ENV=$(ENV)' first."; \
	fi

status: ## Show deployment status and URLs
	@echo "ğŸ“Š Deployment Status for $(ENV)"
	@echo "================================"
	@echo ""
	@if terraform output lambda_function_name >/dev/null 2>&1; then \
		echo "âœ… Infrastructure is deployed"; \
		echo ""; \
		echo "ğŸ”— API URLs:"; \
		echo "  API Gateway: $$(terraform output -raw api_gateway_url)"; \
		echo "  Lambda URL:  $$(terraform output -raw lambda_function_url)"; \
		echo ""; \
		echo "ğŸ©º Health Check URLs:"; \
		echo "  API Gateway: $$(terraform output -raw health_check_url_api_gateway)"; \
		echo "  Lambda URL:  $$(terraform output -raw health_check_url_lambda)"; \
		echo ""; \
		echo "ğŸ“ CloudWatch Logs:"; \
		echo "  Log Group: $$(terraform output -raw lambda_log_group_name)"; \
	else \
		echo "âŒ Infrastructure not deployed"; \
		echo "Run 'make apply ENV=$(ENV)' to deploy"; \
	fi

# Build and prepare API
build-api: ## Build the API before deployment
	@echo "ğŸ”¨ Building API..."
	@cd ../apps/api && yarn install && yarn build

# Full deployment workflow
deploy: build-api plan apply test ## Full deployment workflow (build + plan + apply + test)
	@echo "ğŸ‰ Deployment complete!"

# Quick deployment (skip plan)
quick-deploy: build-api apply ## Quick deployment (build + apply, skip plan)
	@echo "âš¡ Quick deployment complete!"
